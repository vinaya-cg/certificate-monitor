# Secure Dashboard Module - Upload files to private S3 bucket
# Files will be served through CloudFront only

# Upload HTML files
resource "aws_s3_object" "index_html" {
  bucket       = var.bucket_name
  key          = "index.html"
  source       = "${var.dashboard_source_path}/index.html"
  content_type = "text/html"
  etag         = filemd5("${var.dashboard_source_path}/index.html")

  cache_control = "no-cache, no-store, must-revalidate"
}

resource "aws_s3_object" "login_html" {
  bucket       = var.bucket_name
  key          = "login.html"
  source       = "${var.dashboard_source_path}/login.html"
  content_type = "text/html"
  etag         = filemd5("${var.dashboard_source_path}/login.html")

  cache_control = "no-cache, no-store, must-revalidate"
}

resource "aws_s3_object" "error_html" {
  bucket       = var.bucket_name
  key          = "error.html"
  source       = "${var.dashboard_source_path}/error.html"
  content_type = "text/html"
  etag         = filemd5("${var.dashboard_source_path}/error.html")

  cache_control = "no-cache, no-store, must-revalidate"
}

# Upload JavaScript files with Cognito configuration injected
resource "aws_s3_object" "dashboard_js" {
  bucket       = var.bucket_name
  key          = "dashboard.js"
  content_type = "application/javascript"
  etag         = md5(local.dashboard_js_content)

  content = local.dashboard_js_content

  cache_control = "public, max-age=3600"
}

resource "aws_s3_object" "auth_js" {
  bucket       = var.bucket_name
  key          = "auth.js"
  content_type = "application/javascript"
  etag         = md5(local.auth_js_content)

  content = local.auth_js_content

  cache_control = "public, max-age=3600"
}

# Upload auth-cognito.js with Cognito configuration injected
resource "aws_s3_object" "auth_cognito_js" {
  bucket       = var.bucket_name
  key          = "auth-cognito.js"
  content_type = "application/javascript"
  etag         = md5(local.auth_cognito_js_content)

  content = local.auth_cognito_js_content

  cache_control = "no-cache, no-store, must-revalidate"
}

# Upload images
resource "aws_s3_object" "sogeti_logo" {
  bucket       = var.bucket_name
  key          = "images/sogeti-logo.png"
  source       = "${var.dashboard_source_path}/images/sogeti-logo.png"
  content_type = "image/png"
  etag         = filemd5("${var.dashboard_source_path}/images/sogeti-logo.png")

  cache_control = "public, max-age=31536000"
}

resource "aws_s3_object" "postnl_logo" {
  bucket       = var.bucket_name
  key          = "images/postnl-logo.png"
  source       = "${var.dashboard_source_path}/images/postnl-logo.png"
  content_type = "image/png"
  etag         = filemd5("${var.dashboard_source_path}/images/postnl-logo.png")

  cache_control = "public, max-age=31536000"
}

# Local variables for JavaScript content with injected configuration
locals {
  # Read and modify dashboard.js to inject API URL
  dashboard_js_template = file("${var.dashboard_source_path}/dashboard.js")
  dashboard_js_with_base_url = replace(
    local.dashboard_js_template,
    "const API_BASE_URL = 'PLACEHOLDER_API_BASE_URL';",
    "const API_BASE_URL = '${var.api_gateway_url}';"
  )
  dashboard_js_content = replace(
    local.dashboard_js_with_base_url,
    "const API_URL = 'PLACEHOLDER_API_URL';",
    "const API_URL = '${var.api_gateway_url}/certificates';"
  )

  # Create auth-cognito.js with Cognito configuration (PORTABLE VERSION)
  # This file will be auto-generated with correct values for any deployment
  auth_cognito_js_content = <<-EOT
// Cognito Configuration - Auto-generated by Terraform
const COGNITO_CONFIG = {
    userPoolId: '${var.cognito_user_pool_id}',
    clientId: '${var.cognito_client_id}',
    region: '${var.aws_region}',
    identityPoolId: '${var.cognito_identity_pool_id}',
    domain: '${var.cognito_domain}'
};

// Initialize Amazon Cognito
const poolData = {
    UserPoolId: COGNITO_CONFIG.userPoolId,
    ClientId: COGNITO_CONFIG.clientId
};

let userPool;
let cognitoUser;

// Initialize on page load
if (typeof AmazonCognitoIdentity !== 'undefined') {
    userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);
}

// Check if user is authenticated
function isAuthenticated() {
    const cognitoUser = userPool.getCurrentUser();
    
    if (cognitoUser != null) {
        return new Promise((resolve, reject) => {
            cognitoUser.getSession((err, session) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(session.isValid());
            });
        });
    }
    return Promise.resolve(false);
}

// Get current user info
function getCurrentUser() {
    const cognitoUser = userPool.getCurrentUser();
    
    if (cognitoUser != null) {
        return new Promise((resolve, reject) => {
            cognitoUser.getSession((err, session) => {
                if (err) {
                    reject(err);
                    return;
                }
                
                cognitoUser.getUserAttributes((err, attributes) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    
                    const userInfo = {
                        username: cognitoUser.getUsername(),
                        email: attributes.find(attr => attr.Name === 'email')?.Value,
                        name: attributes.find(attr => attr.Name === 'name')?.Value,
                        groups: session.getAccessToken().payload['cognito:groups'] || []
                    };
                    
                    resolve(userInfo);
                });
            });
        });
    }
    return Promise.resolve(null);
}

// Get ID token for API calls
function getIdToken() {
    const cognitoUser = userPool.getCurrentUser();
    
    if (cognitoUser != null) {
        return new Promise((resolve, reject) => {
            cognitoUser.getSession((err, session) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(session.getIdToken().getJwtToken());
            });
        });
    }
    return Promise.resolve(null);
}

// Sign in user
function signIn(email, password) {
    const authenticationData = {
        Username: email,
        Password: password
    };
    
    const authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(authenticationData);
    
    const userData = {
        Username: email,
        Pool: userPool
    };
    
    const cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);
    
    return new Promise((resolve, reject) => {
        cognitoUser.authenticateUser(authenticationDetails, {
            onSuccess: (result) => {
                resolve(result);
            },
            onFailure: (err) => {
                reject(err);
            },
            newPasswordRequired: (userAttributes, requiredAttributes) => {
                // User needs to set a new password
                reject({ message: 'New password required', code: 'NEW_PASSWORD_REQUIRED', userAttributes, requiredAttributes, cognitoUser });
            }
        });
    });
}

// Change password (for first-time login)
function changePassword(cognitoUser, newPassword, userAttributes) {
    return new Promise((resolve, reject) => {
        // CRITICAL: Pass ONLY an empty object to avoid "Cannot modify an already provided email" error
        // Cognito automatically retains all existing attributes when you pass {}
        // DO NOT pass email, email_verified, sub, or any other attributes
        
        console.log('Changing password with empty attributes object');
        
        // Always pass empty object - Cognito will preserve all existing user attributes
        cognitoUser.completeNewPasswordChallenge(newPassword, {}, {
            onSuccess: (result) => {
                console.log('Password change successful');
                resolve(result);
            },
            onFailure: (err) => {
                console.error('Password change failed:', err);
                reject(err);
            }
        });
    });
}

// Sign out user
function signOut() {
    const cognitoUser = userPool.getCurrentUser();
    if (cognitoUser != null) {
        cognitoUser.signOut();
    }
    window.location.href = '/login.html';
}

// Protect page - redirect to login if not authenticated
async function protectPage() {
    try {
        const authenticated = await isAuthenticated();
        if (!authenticated) {
            window.location.href = '/login.html';
        }
    } catch (error) {
        console.error('Authentication check failed:', error);
        window.location.href = '/login.html';
    }
}

// Check permissions
async function hasPermission(requiredGroup) {
    try {
        const user = await getCurrentUser();
        if (!user) return false;
        
        const userGroups = user.groups || [];
        
        // Admins have all permissions
        if (userGroups.includes('Admins')) return true;
        
        // Check for specific group
        if (requiredGroup && userGroups.includes(requiredGroup)) return true;
        
        return false;
    } catch (error) {
        console.error('Permission check failed:', error);
        return false;
    }
}
EOT

  # Create auth.js with Cognito configuration
  auth_js_content = <<-EOT
// Cognito Configuration - Auto-generated by Terraform
const COGNITO_CONFIG = {
    userPoolId: '${var.cognito_user_pool_id}',
    clientId: '${var.cognito_client_id}',
    region: '${var.aws_region}',
    identityPoolId: '${var.cognito_identity_pool_id}',
    domain: '${var.cognito_domain}'
};

// Initialize Amazon Cognito
const poolData = {
    UserPoolId: COGNITO_CONFIG.userPoolId,
    ClientId: COGNITO_CONFIG.clientId
};

let userPool;
let cognitoUser;

// Initialize on page load
if (typeof AmazonCognitoIdentity !== 'undefined') {
    userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);
}

// Check if user is authenticated
function isAuthenticated() {
    const cognitoUser = userPool.getCurrentUser();
    
    if (cognitoUser != null) {
        return new Promise((resolve, reject) => {
            cognitoUser.getSession((err, session) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(session.isValid());
            });
        });
    }
    return Promise.resolve(false);
}

// Get current user info
function getCurrentUser() {
    const cognitoUser = userPool.getCurrentUser();
    
    if (cognitoUser != null) {
        return new Promise((resolve, reject) => {
            cognitoUser.getSession((err, session) => {
                if (err) {
                    reject(err);
                    return;
                }
                
                cognitoUser.getUserAttributes((err, attributes) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    
                    const userInfo = {
                        username: cognitoUser.getUsername(),
                        email: attributes.find(attr => attr.Name === 'email')?.Value,
                        name: attributes.find(attr => attr.Name === 'name')?.Value,
                        groups: session.getAccessToken().payload['cognito:groups'] || []
                    };
                    
                    resolve(userInfo);
                });
            });
        });
    }
    return Promise.resolve(null);
}

// Get ID token for API calls
function getIdToken() {
    const cognitoUser = userPool.getCurrentUser();
    
    if (cognitoUser != null) {
        return new Promise((resolve, reject) => {
            cognitoUser.getSession((err, session) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(session.getIdToken().getJwtToken());
            });
        });
    }
    return Promise.resolve(null);
}

// Sign in user
function signIn(email, password) {
    const authenticationData = {
        Username: email,
        Password: password
    };
    
    const authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(authenticationData);
    
    const userData = {
        Username: email,
        Pool: userPool
    };
    
    const cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);
    
    return new Promise((resolve, reject) => {
        cognitoUser.authenticateUser(authenticationDetails, {
            onSuccess: (result) => {
                resolve(result);
            },
            onFailure: (err) => {
                reject(err);
            },
            newPasswordRequired: (userAttributes, requiredAttributes) => {
                // User needs to set a new password
                reject({ message: 'New password required', code: 'NEW_PASSWORD_REQUIRED', userAttributes, requiredAttributes, cognitoUser });
            }
        });
    });
}

// Change password (for first-time login)
function changePassword(cognitoUser, newPassword, userAttributes) {
    return new Promise((resolve, reject) => {
        // Remove unwanted attributes
        delete userAttributes.email_verified;
        delete userAttributes.phone_number_verified;
        
        cognitoUser.completeNewPasswordChallenge(newPassword, userAttributes, {
            onSuccess: (result) => {
                resolve(result);
            },
            onFailure: (err) => {
                reject(err);
            }
        });
    });
}

// Sign out user
function signOut() {
    const cognitoUser = userPool.getCurrentUser();
    if (cognitoUser != null) {
        cognitoUser.signOut();
    }
    window.location.href = '/login.html';
}

// Protect page - redirect to login if not authenticated
async function protectPage() {
    try {
        const authenticated = await isAuthenticated();
        if (!authenticated) {
            window.location.href = '/login.html';
        }
    } catch (error) {
        console.error('Authentication check failed:', error);
        window.location.href = '/login.html';
    }
}

// Check permissions
async function hasPermission(requiredGroup) {
    try {
        const user = await getCurrentUser();
        if (!user) return false;
        
        const userGroups = user.groups || [];
        
        // Admins have all permissions
        if (userGroups.includes('Admins')) return true;
        
        // Check for specific group
        if (requiredGroup && userGroups.includes(requiredGroup)) return true;
        
        return false;
    } catch (error) {
        console.error('Permission check failed:', error);
        return false;
    }
}
EOT
}
